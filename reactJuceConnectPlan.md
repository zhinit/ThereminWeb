# Plan: 440Hz Sine Wave with React + C++ WASM

## Goal

Build a minimal Vite React app with a button that plays a 440Hz sine wave generated by C++ compiled to WebAssembly.

---

## Project Structure

```
/TherminWeb
├── /frontend                     # Vite React app
│   ├── /src
│   │   ├── App.tsx
│   │   ├── App.css
│   │   ├── main.tsx
│   │   ├── index.css
│   │   └── assets/
│   ├── /public
│   │   ├── audio-engine.js       # Compiled WASM loader (build output)
│   │   ├── audio-engine.wasm     # Compiled WASM binary (build output)
│   │   └── dsp-processor.js      # AudioWorklet (must be in public)
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   └── index.html
├── /dsp                          # C++ audio DSP code
│   ├── oscillator.cpp            # C++ sine oscillator
│   └── CMakeLists.txt            # Emscripten build config
└── reactJuceConnectPlan.md
```

---

## Steps

### 1. Set Up Emscripten

- Install Emscripten SDK
- Run `source ~/SDKs/emsdk/emsdk_env.sh` to activate
- Verify: `emcc --version`

### 2. Write C++ Oscillator

Create `dsp/oscillator.cpp` (at the project root, alongside `frontend/`):

```cpp
#include <cmath>
#include <emscripten/bind.h>

class SineOscillator {
    float phase = 0.0f;
    float frequency = 440.0f;
    float sampleRate = 44100.0f;
    bool playing = false;

public:
    void setPlaying(bool p) { playing = p; }
    void setFrequency(float f) { frequency = f; }
    void setSampleRate(float sr) { sampleRate = sr; }

    void process(uintptr_t outputPtr, int numSamples) {
        float* output = reinterpret_cast<float*>(outputPtr);
        float phaseIncrement = frequency / sampleRate;

        for (int i = 0; i < numSamples; i++) {
            if (playing) {
                output[i] = std::sin(phase * 2.0f * M_PI) * 0.3f;
                phase += phaseIncrement;
                if (phase >= 1.0f) phase -= 1.0f;
            } else {
                output[i] = 0.0f;
            }
        }
    }
};

EMSCRIPTEN_BINDINGS(audio_module) {
    emscripten::class_<SineOscillator>("SineOscillator")
        .constructor()
        .function("setPlaying", &SineOscillator::setPlaying)
        .function("setFrequency", &SineOscillator::setFrequency)
        .function("setSampleRate", &SineOscillator::setSampleRate)
        .function("process", &SineOscillator::process, emscripten::allow_raw_pointers());
}
```

### 3. Compile to WASM

Run from the project root (`TherminWeb/`):

```bash
emcc dsp/oscillator.cpp \
    -o frontend/public/audio-engine.js \
    -s MODULARIZE=1 \
    -s EXPORT_NAME="createAudioEngine" \
    -s ENVIRONMENT='web,worker,shell' \
    -s SINGLE_FILE=1 \
    -s EXPORTED_FUNCTIONS='["_malloc","_free"]' \
    -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap","HEAPF32"]' \
    --bind
```

Note: `SINGLE_FILE=1` embeds WASM as base64 in the JS file (no separate .wasm file needed).

### 4. Create AudioWorklet Processor

Create `frontend/public/dsp-processor.js` (must be in public, loaded at runtime):

```javascript
class DSPProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.engine = null;
    this.heapBuffer = null;
    this.port.onmessage = (e) => this.handleMessage(e.data);
  }

  async handleMessage(data) {
    if (data.type === "init") {
      // Import and instantiate WASM
      importScripts("audio-engine.js");
      const module = await createAudioEngine();
      this.engine = new module.SineOscillator();
      this.engine.setSampleRate(sampleRate);
      this.module = module;
      this.port.postMessage({ type: "ready" });
    }
    if (data.type === "play") {
      this.engine?.setPlaying(true);
    }
    if (data.type === "stop") {
      this.engine?.setPlaying(false);
    }
  }

  process(inputs, outputs, parameters) {
    if (!this.engine || !this.module) return true;

    const output = outputs[0][0];
    const numSamples = output.length;

    // Allocate WASM heap memory for output
    if (!this.heapBuffer || this.heapBuffer.length < numSamples) {
      this.heapBuffer = this.module._malloc(numSamples * 4);
    }

    // Process audio in C++
    this.engine.process(this.heapBuffer, numSamples);

    // Copy from WASM heap to output buffer
    const wasmOutput = new Float32Array(
      this.module.HEAPF32.buffer,
      this.heapBuffer,
      numSamples
    );
    output.set(wasmOutput);

    return true;
  }
}

registerProcessor("dsp-processor", DSPProcessor);
```

### 5. Vite React App (Already Created)

The Vite React app already exists in `frontend/`. If starting fresh:

```bash
cd TherminWeb
npm create vite@latest frontend -- --template react-ts
cd frontend
npm install
```

### 6. Write React Component

Replace `frontend/src/App.tsx`:

```tsx
import { useState, useRef } from "react";

function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const audioContextRef = useRef<AudioContext | null>(null);
  const workletNodeRef = useRef<AudioWorkletNode | null>(null);

  const initAudio = async () => {
    if (audioContextRef.current) return;

    const ctx = new AudioContext();
    await ctx.audioWorklet.addModule("/dsp-processor.js");

    const node = new AudioWorkletNode(ctx, "dsp-processor");
    node.connect(ctx.destination);

    node.port.onmessage = (e) => {
      if (e.data.type === "ready") {
        setIsReady(true);
      }
    };

    node.port.postMessage({ type: "init" });

    audioContextRef.current = ctx;
    workletNodeRef.current = node;
  };

  const togglePlay = async () => {
    if (!audioContextRef.current) {
      await initAudio();
    }

    if (audioContextRef.current?.state === "suspended") {
      await audioContextRef.current.resume();
    }

    if (isPlaying) {
      workletNodeRef.current?.port.postMessage({ type: "stop" });
    } else {
      workletNodeRef.current?.port.postMessage({ type: "play" });
    }
    setIsPlaying(!isPlaying);
  };

  return (
    <div style={{ padding: "2rem", textAlign: "center" }}>
      <h1>C++ WASM Sine Wave</h1>
      <button
        onClick={togglePlay}
        style={{ padding: "1rem 2rem", fontSize: "1.2rem" }}
      >
        {isPlaying ? "Stop" : "Play 440Hz"}
      </button>
      {!isReady && audioContextRef.current && <p>Loading WASM...</p>}
    </div>
  );
}

export default App;
```

### 7. Configure Vite

Update `frontend/vite.config.ts` to serve WASM correctly:

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    headers: {
      "Cross-Origin-Opener-Policy": "same-origin",
      "Cross-Origin-Embedder-Policy": "require-corp",
    },
  },
});
```

### 8. Run and Test

```bash
cd frontend
npm run dev
```

Click the button. You should hear 440Hz.

---

## Checklist

- [x] Emscripten installed and working
- [x] C++ oscillator compiles to WASM
- [x] WASM files in `frontend/public/` folder
- [x] `dsp-processor.js` in `frontend/public/`
- [ ] AudioWorklet loads WASM module
- [ ] React button toggles playback
- [ ] 440Hz tone plays in browser

---

## Troubleshooting

| Issue                      | Fix                                                |
| -------------------------- | -------------------------------------------------- |
| WASM won't load in worklet | Check CORS headers in `frontend/vite.config.ts`    |
| No sound                   | Check browser console, ensure AudioContext resumed |
| `importScripts` fails      | Make sure audio-engine.js is in `frontend/public/` |
| Clicks/pops                | Increase buffer size or add gain smoothing         |
